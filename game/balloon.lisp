(defpackage cl-csr-jintori/game/balloon
  (:use :cl
        :cl-ps-ecs
        :cl-csr-2d-game)
  (:export :add-balloon
           :find-collided-balloon
           :try-changing-balloon-owner)
  (:import-from :cl-csr-jintori/game/parameter
                :get-param)
  (:import-from :proto-cl-client-side-rendering
                :mouse-up-p
                :mouse-down-now-p
                :touch-summary-up-p
                :touch-summary-down-now-p))
(in-package :cl-csr-jintori/game/balloon)

(defmacro get-balloon-param (&rest keys)
  `(get-param :balloon ,@keys))

(defmacro do-balloon ((var) &body body)
  `(do-tagged-ecs-entities (,var :balloon)
     ,@body))

;; --- interface --- ;;

(defun add-balloon (&key x y client-id color)
  ;; TODO: Check if the pointed place is empty.
  (let ((balloon (make-ecs-entity))
        (r (get-balloon-param :first-r)))
    (add-entity-tag balloon :balloon)
    (add-ecs-component-list
     balloon
     (make-point-2d :x x :y y)
     (make-balloon-model r color)
     (make-script-2d :func (lambda (entity)
                             (process-game-state
                              (get-entity-param entity :state-manager))))
     (init-entity-params
      :state-manager (init-game-state-manager
                      (make-state-expand :balloon balloon))
      :client-id client-id
      :color color
      :r r))
    (add-ecs-entity balloon)))

(defun try-changing-balloon-owner (&key balloon client-id color)
  (check-entity-tags balloon :balloon)
  (when (has-entity-tag balloon :balloon-fragile)
    (delete-entity-tag balloon :balloon-fragile)
    (set-entity-param balloon
                      :client-id client-id
                      :color color)))

(defun find-collided-balloon (&key x y r)
  (do-balloon (balloon)
    (when (balloon-collided-p balloon x y r)
      (return-from find-collided-balloon balloon))))

;; --- internal --- ;;

(defun make-balloon-model (r color)
  (make-model-2d :mesh (make-circle-mesh :r r :color color
                                         :fill-p t)))
(defun expand-balloon (balloon diff-r)
  (check-entity-tags balloon :balloon)
  (register-next-frame-func
   (lambda ()
     ;; TODO: Prevent sinking into another balloon
     ;; TODO: Prevent extending out of screen
     (delete-ecs-component-type 'model-2d balloon)
     (let ((r (+ (get-entity-param balloon :r) diff-r)))
       (add-ecs-component-list
        balloon
        (make-balloon-model r (get-entity-param balloon :color)))
       (setf (get-entity-param balloon :r) r))))
  (multiple-value-bind (x y r) (get-balloon-xyr balloon)
    (not (or (get-collided-balloon-list balloon x y (+ r diff-r))
             (out-of-screen-p x y (+ r diff-r))))))

(defun get-collided-balloon-list (balloon x y r)
  (let ((result nil))
    (do-balloon (target-balloon)
      (when (and (not (eq balloon target-balloon))
                 (balloon-collided-p target-balloon x y r))
        (push target-balloon result)))
    result))

(defun balloon-collided-p (balloon x y r)
  (let ((balloon-pos (calc-global-point balloon))
        (balloon-r (get-entity-param balloon :r)))
    (<= (calc-dist-p2 balloon-pos
                      (make-vector-2d :x x :y y))
        (expt (+ r balloon-r) 2))))

(defun out-of-screen-p (x y r)
  (or (> (+ x r) #lx1000)
      (< (- x r) 0)
      (> (+ y r) #ly1000)
      (< (- y r) 0)))

(defun get-balloon-xyr (balloon)
  (let ((pos (calc-global-point balloon))
        (r (get-entity-param balloon :r)))
    (values (point-2d-x pos)
            (point-2d-y pos)
            r)))

;; - state - ;;

(defstruct (balloon-state (:include game-state))
  balloon)

(defstruct (state-expand
             (:include balloon-state
                       (process (state-lambda (balloon)
                                  (process-state-expand balloon))))))

(defun process-state-expand (balloon)
  (let* ((can-expand-p (expand-balloon balloon (get-balloon-param :expand-speed)))
         (id (get-entity-param balloon :client-id))
         (up-p (and (mouse-up-p id :left) (touch-summary-up-p id))))
    (when (or (not can-expand-p) up-p)
      (make-state-guard :balloon balloon))))

;; TODO: Implement animation
(defstruct (state-guard
             (:include balloon-state
                       (process (state-lambda (balloon rest-guard-time)
                                  (decf rest-guard-time)
                                  (when (<= rest-guard-time 0)
                                    (make-state-fragile :balloon balloon))))))
  (rest-guard-time (get-balloon-param :guard-time)))

;; TODO: Implement changing owner if another client touch
(defstruct (state-fragile
             (:include balloon-state
                       (start-process (state-lambda (balloon)
                                        (add-entity-tag balloon :balloon-fragile)
                                        t))
                       (process (state-lambda (balloon)
                                  (unless (has-entity-tag balloon :balloon-fragile)
                                    (expand-balloon balloon 0)
                                    (make-state-guard :balloon balloon)))))))
